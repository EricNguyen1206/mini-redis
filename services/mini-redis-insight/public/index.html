<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mini Redis Insight</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: #f8f9fa;
        color: #333;
        line-height: 1.6;
      }

      .header {
        background: #fff;
        border-bottom: 1px solid #e9ecef;
        padding: 1rem 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        position: sticky;
        top: 0;
        z-index: 10;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 0 1rem;
      }

      .header h1 {
        color: #dc3545;
        font-size: 2rem;
        font-weight: 700;
      }

      .header .subtitle {
        color: #6c757d;
        font-size: 0.9rem;
        margin-top: 0.25rem;
      }

      .header-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .connection-status {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        border-radius: 20px;
        font-size: 0.85rem;
        font-weight: 500;
      }

      .connection-status.connected {
        background: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }

      .connection-status.disconnected {
        background: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
      }

      .connection-status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
      }

      .connection-status.connected .connection-status-dot {
        background: #28a745;
      }

      .connection-status.disconnected .connection-status-dot {
        background: #dc3545;
      }

      .main-content {
        padding: 2rem 0;
      }

      .tabs {
        display: flex;
        background: #fff;
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }

      .tab {
        flex: 1;
        padding: 1rem;
        text-align: center;
        background: #f8f9fa;
        border: none;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 500;
        transition: all 0.3s ease;
      }

      .tab.active {
        background: #dc3545;
        color: white;
      }

      .tab:hover:not(.active) {
        background: #e9ecef;
      }

      .tab-content {
        display: none;
        background: #fff;
        border-bottom-left-radius: 8px;
        border-bottom-right-radius: 8px;
        padding: 2rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .tab-content.active {
        display: block;
      }

      .data-commands-grid {
        display: grid;
        grid-template-columns: 2fr 1fr;
        gap: 2rem;
        height: 100%;
      }

      .data-section {
        min-height: 500px;
      }

      .command-section {
        background: #f8f9fa;
        border-radius: 8px;
        padding: 1.5rem;
        min-height: 500px;
      }

      .command-controls {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        margin-bottom: 1.5rem;
      }

      .command-controls > div {
        display: flex;
        align-items: center;
      }

      .command-controls label {
        display: block;
        font-weight: 500;
        margin-bottom: 0.25rem;
        color: #495057;
        width: 80px;
      }

      .command-controls input,
      .command-controls select {
        padding: 0.5rem;
        border: 2px solid #e9ecef;
        border-radius: 6px;
        font-size: 0.9rem;
        flex: 1;
      }

      .command-controls input:focus,
      .command-controls select:focus {
        outline: none;
        border-color: #dc3545;
      }

      .command-controls .hidden {
        display: none;
      }

      .data-table-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
      }

      .data-table-actions {
        display: flex;
        gap: 1rem;
      }

      .status-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #e9ecef;
        padding: 1rem;
        border-radius: 6px;
        margin-bottom: 2rem;
        font-size: 0.9rem;
      }

      .status-indicator {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #28a745;
      }

      .command-input {
        display: flex;
        gap: 1rem;
        margin-bottom: 1rem;
      }

      .command-input input {
        flex: 1;
        padding: 0.75rem;
        border: 2px solid #e9ecef;
        border-radius: 6px;
        font-size: 1rem;
        font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
      }

      .command-input input:focus {
        outline: none;
        border-color: #dc3545;
      }

      .btn {
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 6px;
        font-size: 1rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .btn-primary {
        background: #dc3545;
        color: white;
      }

      .btn-primary:hover {
        background: #c82333;
      }

      .btn-secondary {
        background: #6c757d;
        color: white;
      }

      .btn-secondary:hover {
        background: #5a6268;
      }

      .btn-danger {
        background: #dc3545;
        color: white;
      }

      .btn-danger:hover {
        background: #c82333;
      }

      .command-result {
        background: #ffffff;
        border: 2px solid #e9ecef;
        border-radius: 6px;
        padding: 1rem;
        font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
        font-size: 0.9rem;
        white-space: pre-wrap;
        min-height: 100px;
        max-height: 400px;
        overflow-y: auto;
      }

      .data-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 1rem;
      }

      .data-table th,
      .data-table td {
        padding: 1rem;
        text-align: left;
        border-bottom: 1px solid #e9ecef;
      }

      .data-table th {
        background: #f8f9fa;
        font-weight: 600;
        color: #495057;
      }

      .data-table tr:hover {
        background: #f8f9fa;
      }

      .ttl-badge {
        display: inline-block;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 0.8rem;
        font-weight: 500;
      }

      .ttl-active {
        background: #fff3cd;
        color: #856404;
      }

      .ttl-none {
        background: #d1ecf1;
        color: #0c5460;
      }

      .key-actions {
        display: flex;
        gap: 0.5rem;
      }

      .key-actions button {
        padding: 0.25rem 0.5rem;
        font-size: 0.8rem;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }

      .pubsub-section {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 2rem;
      }

      .pubsub-command-interface {
        background: #f8f9fa;
        border-radius: 8px;
        padding: 1.5rem;
        border: 1px solid #e9ecef;
      }

      .pubsub-form-row {
        display: flex;
        gap: 1rem;
        margin-bottom: 1rem;
        align-items: end;
      }

      .pubsub-form-row:last-child {
        margin-bottom: 0;
      }

      .pubsub-input-group {
        display: flex;
        flex-direction: column;
        min-width: 150px;
      }

      .pubsub-input-group label {
        font-size: 0.9rem;
        font-weight: 500;
        color: #495057;
        margin-bottom: 0.25rem;
      }

      .pubsub-input-group .form-control {
        padding: 0.5rem;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 0.9rem;
      }

      .pubsub-input-group select.form-control {
        cursor: pointer;
      }

      .pubsub-command-result {
        background: #e9ecef;
        border-radius: 4px;
        padding: 0.75rem;
        font-family: "Courier New", monospace;
        font-size: 0.85rem;
        border-left: 4px solid #007bff;
      }

      .pubsub-command-result.success {
        background: #d4edda;
        border-left-color: #28a745;
        color: #155724;
      }

      .pubsub-command-result.error {
        background: #f8d7da;
        border-left-color: #dc3545;
        color: #721c24;
      }

      .performance-section {
        display: flex;
        flex-direction: column;
        gap: 2rem;
      }

      .performance-group {
        background: #f8f9fa;
        border-radius: 8px;
        padding: 1.5rem;
        border: 1px solid #e9ecef;
      }

      .performance-group h3 {
        margin: 0 0 1rem 0;
        color: #495057;
        font-size: 1.2rem;
      }

      .metrics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 1rem;
      }

      .metric-card {
        background: white;
        border-radius: 8px;
        padding: 1rem;
        border: 1px solid #dee2e6;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        height: 400px; /* Reduced total height for more compact layout */
      }

      .metric-card h4 {
        color: #6c757d;
        font-size: 0.9rem;
        font-weight: 500;
        flex-shrink: 0; /* Prevent title from shrinking */
      }

      .metric-card__header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 0.5rem;
      }

      .metric-card__header--left {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 0;
      }

      .metric-value {
        font-size: 2rem;
        font-weight: bold;
        color: #007bff;
        flex-shrink: 0; /* Prevent value from shrinking */
      }

      .metric-unit {
        font-size: 0.8rem;
        color: #6c757d;
        flex-shrink: 0; /* Prevent unit from shrinking */
      }

      .metric-chart-container {
        flex: 1; /* Take remaining space */
        position: relative;
        height: 300px; /* Reduced height for more compact charts */
        min-height: 300px;
        max-height: 300px;
      }

      .metric-card canvas {
        position: absolute !important;
        top: 0;
        left: 0;
        width: 100% !important;
        height: 300px !important;
      }

      .performance-section .performance-group:last-child .metrics-grid .metric-card {
        height: 120px;
      }

      .channel-list {
        background: #f8f9fa;
        border-radius: 6px;
        padding: 1rem;
        max-height: 300px;
        overflow-y: auto;
      }

      .channel-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.5rem;
        border-bottom: 1px solid #e9ecef;
      }

      .channel-item:last-child {
        border-bottom: none;
      }

      .subscriber-count {
        background: #dc3545;
        color: white;
        padding: 0.25rem 0.5rem;
        border-radius: 12px;
        font-size: 0.8rem;
      }

      .message-log {
        background: #f8f9fa;
        border-radius: 6px;
        padding: 1rem;
        max-height: 300px;
        overflow-y: auto;
        font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
        font-size: 0.9rem;
      }

      .message-item {
        padding: 0.5rem;
        border-bottom: 1px solid #e9ecef;
        margin-bottom: 0.5rem;
      }

      .message-timestamp {
        color: #6c757d;
        font-size: 0.8rem;
      }

      .loading {
        text-align: center;
        padding: 2rem;
        color: #6c757d;
      }

      .error {
        background: #f8d7da;
        color: #721c24;
        padding: 1rem;
        border-radius: 6px;
        margin-bottom: 1rem;
      }

      .success {
        background: #d4edda;
        color: #155724;
        padding: 1rem;
        border-radius: 6px;
        margin-bottom: 1rem;
      }

      #footer {
        background: #fff;
        border-top: 1px solid #e9ecef;
        padding: 2rem 0;
        margin-top: 3rem;
        text-align: center;
        box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.1);
      }

      #footer p {
        color: #6c757d;
        font-size: 0.9rem;
        margin: 0;
        line-height: 1.5;
      }

      #footer a {
        color: #dc3545;
        text-decoration: none;
        font-weight: 500;
        transition: color 0.3s ease;
      }

      #footer a:hover {
        color: #c82333;
        text-decoration: underline;
      }

      @media (max-width: 768px) {
        .pubsub-section {
          grid-template-columns: 1fr;
        }

        .pubsub-form-row {
          flex-direction: column;
          align-items: stretch;
          gap: 0.5rem;
        }

        .pubsub-input-group {
          min-width: auto;
          width: 100%;
        }

        .pubsub-form-row button {
          margin-left: 0 !important;
          align-self: stretch;
        }

        .data-commands-grid {
          grid-template-columns: 1fr;
          gap: 1rem;
        }

        .data-table-header {
          flex-direction: column;
          align-items: flex-start;
          gap: 1rem;
        }

        .data-table-actions {
          width: 100%;
          justify-content: space-between;
        }

        .command-section {
          margin-top: 1rem;
        }

        .metrics-grid {
          grid-template-columns: 1fr;
          gap: 1rem;
        }

        .metric-card {
          height: 350px; /* Reduced height for mobile layout */
        }

        .metric-chart-container {
          height: 250px; /* Compact chart height for mobile */
          min-height: 250px;
          max-height: 250px;
        }

        .metric-card canvas {
          height: 250px !important; /* Compact canvas height for mobile */
        }

        #footer {
          padding: 1.5rem 0;
          margin-top: 2rem;
        }

        #footer p {
          font-size: 0.8rem;
        }
      }

      /* Toast Notification System */
      .toast-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        gap: 10px;
        pointer-events: none;
        max-width: 400px;
      }

      .toast {
        background: #fff;
        border-radius: 8px;
        padding: 16px 20px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        border-left: 4px solid #007bff;
        display: flex;
        align-items: flex-start;
        gap: 12px;
        pointer-events: auto;
        transform: translateX(100%);
        opacity: 0;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        max-width: 100%;
        word-wrap: break-word;
      }

      .toast.show {
        transform: translateX(0);
        opacity: 1;
      }

      .toast.hide {
        transform: translateX(100%);
        opacity: 0;
      }

      .toast-icon {
        flex-shrink: 0;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
        color: white;
        margin-top: 2px;
      }

      .toast-content {
        flex: 1;
        min-width: 0;
      }

      .toast-title {
        font-weight: 600;
        font-size: 14px;
        margin: 0 0 4px 0;
        line-height: 1.2;
      }

      .toast-message {
        font-size: 13px;
        line-height: 1.4;
        margin: 0;
        color: #6c757d;
        white-space: pre-wrap;
      }

      .toast-close {
        flex-shrink: 0;
        background: none;
        border: none;
        font-size: 18px;
        color: #adb5bd;
        cursor: pointer;
        padding: 0;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
        transition: all 0.2s ease;
      }

      .toast-close:hover {
        background: #f8f9fa;
        color: #495057;
      }

      .toast-close:focus {
        outline: 2px solid #007bff;
        outline-offset: 2px;
      }

      /* Toast Types */
      .toast.success {
        border-left-color: #28a745;
      }

      .toast.success .toast-icon {
        background: #28a745;
      }

      .toast.success .toast-title {
        color: #155724;
      }

      .toast.error {
        border-left-color: #dc3545;
      }

      .toast.error .toast-icon {
        background: #dc3545;
      }

      .toast.error .toast-title {
        color: #721c24;
      }

      .toast.info {
        border-left-color: #17a2b8;
      }

      .toast.info .toast-icon {
        background: #17a2b8;
      }

      .toast.info .toast-title {
        color: #0c5460;
      }

      .toast.warning {
        border-left-color: #ffc107;
      }

      .toast.warning .toast-icon {
        background: #ffc107;
        color: #212529;
      }

      .toast.warning .toast-title {
        color: #856404;
      }

      /* Mobile Responsive */
      @media (max-width: 768px) {
        .toast-container {
          top: 10px;
          right: 10px;
          left: 10px;
          max-width: none;
        }

        .toast {
          padding: 12px 16px;
        }

        .toast-title {
          font-size: 13px;
        }

        .toast-message {
          font-size: 12px;
        }
      }
    </style>
  </head>
  <body>
    <div class="header">
      <div class="container">
        <div class="header-content">
          <div>
            <h1>🎲 Mini Redis Insight</h1>
            <div class="subtitle">Real-time Redis management interface</div>
          </div>
          <div class="connection-status disconnected" id="connection-status">
            <div class="connection-status-dot"></div>
            <span id="connection-status-text">Connecting...</span>
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="main-content">
        <!-- Status Bar -->
        <div class="status-bar">
          <div class="status-indicator">
            <div class="status-dot" id="connection-status"></div>
            <span id="connection-text">Connected</span>
          </div>
          <div>
            <span id="key-count">0 keys</span> |
            <span id="last-update">Never updated</span>
          </div>
        </div>

        <!-- Tabs -->
        <div class="tabs">
          <button class="tab active" onclick="switchTab('data')">📊 Data & Commands</button>
          <button class="tab" onclick="switchTab('pubsub')">📡 Pub/Sub</button>
          <button class="tab" onclick="switchTab('performance')">⚡ Performance</button>
        </div>

        <!-- Data & Commands Tab -->
        <div id="data-tab" class="tab-content active">
          <div class="data-commands-grid">
            <!-- Data Section (Left - 2/3 width) -->
            <div class="data-section">
              <div class="data-table-header">
                <h2>Key-Value Store</h2>
                <div class="data-table-actions">
                  <button class="btn btn-secondary" onclick="loadData()">Refresh</button>
                  <button class="btn btn-danger" onclick="clearAllData()">Clear All Data</button>
                </div>
              </div>

              <div id="data-loading" class="loading">Loading data...</div>
              <div id="data-error" class="error" style="display: none"></div>

              <table class="data-table" id="data-table" style="display: none">
                <thead>
                  <tr>
                    <th>Key</th>
                    <th>Value</th>
                    <th>Type</th>
                    <th>TTL</th>
                  </tr>
                </thead>
                <tbody id="data-table-body"></tbody>
              </table>

              <div id="no-data" style="display: none; text-align: center; padding: 2rem; color: #6c757d">
                No keys found. Use the command interface to add some data.
              </div>
            </div>

            <!-- Command Section (Right - 1/3 width) -->
            <div class="command-section">
              <h3>Execute Commands</h3>

              <div class="command-controls">
                <div>
                  <label for="command-action">Action:</label>
                  <select id="command-action" onchange="handleActionChange()">
                    <option value="PING">PING</option>
                    <option value="GET">GET</option>
                    <option value="SET">SET</option>
                    <option value="DELETE">DELETE</option>
                    <option value="SET_TTL">SET with TTL</option>
                  </select>
                </div>

                <div id="key-input-group">
                  <label for="command-key">Key:</label>
                  <input type="text" id="command-key" placeholder="Enter key name" />
                </div>

                <div id="value-input-group" class="hidden">
                  <label for="command-value">Value:</label>
                  <input type="text" id="command-value" placeholder="Enter value" />
                </div>

                <div id="ttl-input-group" class="hidden">
                  <label for="command-ttl">TTL (sec):</label>
                  <input type="number" id="command-ttl" placeholder="Enter TTL in seconds" min="1" />
                </div>

                <button class="btn btn-primary" onclick="executeCommand()">Execute</button>
              </div>

              <div id="command-error" class="error" style="display: none"></div>
              <div id="command-success" class="success" style="display: none"></div>

              <div class="command-result" id="command-result">
                Ready to execute commands... Examples: - PING: Test connection - GET: Retrieve a key's value - SET:
                Store a key-value pair - DELETE: Remove a key - SET with TTL: Store with expiration
              </div>
            </div>
          </div>
        </div>

        <!-- Pub/Sub Tab -->
        <div id="pubsub-tab" class="tab-content">
          <h2>Publish/Subscribe Monitor</h2>

          <div class="pubsub-section">
            <div>
              <h3>Active Channels</h3>
              <div class="channel-list" id="channel-list">
                <div style="text-align: center; color: #6c757d; padding: 2rem">No active channels</div>
              </div>
            </div>

            <div>
              <h3>Message Log</h3>
              <div class="message-log" id="message-log">
                <div style="text-align: center; color: #6c757d; padding: 2rem">No messages yet</div>
              </div>
            </div>
          </div>

          <div style="margin-top: 2rem">
            <h3>Test Pub/Sub</h3>
            <div class="pubsub-command-interface" style="margin-top: 1rem">
              <div class="pubsub-form-row">
                <div class="pubsub-input-group">
                  <label for="pubsub-action">Action:</label>
                  <select id="pubsub-action" class="form-control" onchange="handlePubSubActionChange()">
                    <option value="SUBSCRIBE">SUBSCRIBE</option>
                    <option value="PUBLISH">PUBLISH</option>
                    <option value="UNSUBSCRIBE">UNSUBSCRIBE</option>
                  </select>
                </div>
                <div class="pubsub-input-group">
                  <label for="pubsub-channel">Channel:</label>
                  <input
                    type="text"
                    id="pubsub-channel"
                    class="form-control"
                    placeholder="Enter channel name"
                    value="test_channel"
                  />
                </div>
              </div>
              <div class="pubsub-form-row" id="pubsub-message-row" style="display: none">
                <div class="pubsub-input-group" style="flex: 1">
                  <label for="pubsub-message">Message:</label>
                  <input type="text" id="pubsub-message" class="form-control" placeholder="Enter message content" />
                </div>
              </div>
              <div class="pubsub-form-row">
                <button class="btn btn-primary" onclick="executePubSubCommand()" style="margin-left: auto">
                  Send Command
                </button>
              </div>
              <div
                id="pubsub-command-result"
                class="pubsub-command-result"
                style="display: none; margin-top: 1rem"
              ></div>
            </div>
          </div>
        </div>

        <!-- Performance Tab -->
        <div id="performance-tab" class="tab-content">
          <h2>Real-time Performance Metrics</h2>

          <div class="performance-section">
            <!-- Cache Performance Metrics -->
            <div class="performance-group">
              <h3>Cache Performance</h3>
              <div class="metrics-grid">
                <div class="metric-card">
                  <div class="metric-card__header">
                    <div class="metric-card__header--left">
                      <h4>Requests Per Second</h4>
                      <div class="metric-unit">commands/sec</div>
                    </div>
                    <div class="metric-value" id="cache-rps">0</div>
                  </div>
                  <div class="metric-chart-container">
                    <canvas id="cache-rps-chart"></canvas>
                  </div>
                </div>
                <div class="metric-card">
                  <div class="metric-card__header">
                    <div class="metric-card__header--left">
                      <h4>P99 Latency</h4>
                      <div class="metric-unit">milliseconds</div>
                    </div>
                    <div class="metric-value" id="cache-latency">0</div>
                  </div>
                  <div class="metric-chart-container">
                    <canvas id="cache-latency-chart"></canvas>
                  </div>
                </div>
                <div class="metric-card">
                  <div class="metric-card__header">
                    <div class="metric-card__header--left">
                      <h4>Cache Hit Rate</h4>
                      <div class="metric-unit">percent</div>
                    </div>
                    <div class="metric-value" id="cache-hit-rate">0</div>
                  </div>
                  <div class="metric-chart-container">
                    <canvas id="cache-hit-rate-chart"></canvas>
                  </div>
                </div>
              </div>
            </div>

            <!-- Pub/Sub Performance Metrics -->
            <div class="performance-group">
              <h3>Pub/Sub Performance</h3>
              <div class="metrics-grid">
                <div class="metric-card">
                  <div class="metric-card__header">
                    <div class="metric-card__header--left">
                      <h4>Messages Published/Sec</h4>
                      <div class="metric-unit">messages/sec</div>
                    </div>
                    <div class="metric-value" id="pubsub-published">0</div>
                  </div>
                  <div class="metric-chart-container">
                    <canvas id="pubsub-published-chart"></canvas>
                  </div>
                </div>
                <div class="metric-card">
                  <div class="metric-card__header">
                    <div class="metric-card__header--left">
                      <h4>Messages Consumed/Sec</h4>
                      <div class="metric-unit">messages/sec</div>
                    </div>
                    <div class="metric-value" id="pubsub-consumed">0</div>
                  </div>
                  <div class="metric-chart-container">
                    <canvas id="pubsub-consumed-chart"></canvas>
                  </div>
                </div>
                <div class="metric-card">
                  <div class="metric-card__header">
                    <div class="metric-card__header--left">
                      <h4>Message Latency P99</h4>
                      <div class="metric-unit">milliseconds</div>
                    </div>
                    <div class="metric-value" id="pubsub-latency">0</div>
                  </div>
                  <div class="metric-chart-container">
                    <canvas id="pubsub-latency-chart"></canvas>
                  </div>
                </div>
              </div>
            </div>

            <!-- System Metrics -->
            <div class="performance-group">
              <h3>System Metrics</h3>
              <div class="metrics-grid">
                <div class="metric-card">
                  <div class="metric-card__header">
                    <div class="metric-card__header--left">
                      <h4>Active Connections</h4>
                      <div class="metric-unit">connections</div>
                    </div>
                    <div class="metric-value" id="system-connections">0</div>
                  </div>
                </div>

                <div class="metric-card">
                  <div class="metric-card__header">
                    <div class="metric-card__header--left">
                      <h4>Memory Usage</h4>
                      <div class="metric-unit">MB</div>
                    </div>
                    <div class="metric-value" id="system-memory">0</div>
                  </div>
                </div>

                <div class="metric-card">
                  <div class="metric-card__header">
                    <div class="metric-card__header--left">
                      <h4>Uptime</h4>
                      <div class="metric-unit">seconds</div>
                    </div>
                    <div class="metric-value" id="system-uptime">0</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Toast Notification Container -->
    <div id="toast-container" class="toast-container" aria-live="polite" aria-label="Notifications"></div>

    <footer id="footer">
      <div>
        <p>© Copyright 2025, MIT License | <a href="https://github.com/EricNguyen1206">EricNguyen1206</a></p>
      </div>
    </footer>

    <script>
      // Global state
      let currentTab = "data";
      let websocket = null;
      let messageLog = [];
      let isConnected = false;

      // Performance monitoring state
      let performanceCharts = {};
      let performanceData = {
        cache: { rps: [], latency: [], hitRate: [] },
        pubsub: { published: [], consumed: [], latency: [] },
      };
      let maxDataPoints = 60; // Keep 60 seconds of data

      // Toast notification system
      let toastCounter = 0;
      const activeToasts = new Map();

      // Toast notification functions
      function showToast(message, type = "info", title = "", duration = null) {
        const toastId = ++toastCounter;
        const container = document.getElementById("toast-container");

        // Set default durations based on type
        if (duration === null) {
          switch (type) {
            case "success":
              duration = 4000;
              break;
            case "error":
              duration = 8000;
              break;
            case "warning":
              duration = 6000;
              break;
            default:
              duration = 5000;
          }
        }

        // Set default titles based on type
        if (!title) {
          switch (type) {
            case "success":
              title = "Success";
              break;
            case "error":
              title = "Error";
              break;
            case "warning":
              title = "Warning";
              break;
            default:
              title = "Info";
          }
        }

        // Create toast element
        const toast = document.createElement("div");
        toast.className = `toast ${type}`;
        toast.setAttribute("role", "alert");
        toast.setAttribute("aria-live", "assertive");
        toast.setAttribute("aria-atomic", "true");
        toast.id = `toast-${toastId}`;

        // Get icon based on type
        const icons = {
          success: "✓",
          error: "✕",
          warning: "⚠",
          info: "ℹ",
        };

        toast.innerHTML = `
          <div class="toast-icon">${icons[type] || icons.info}</div>
          <div class="toast-content">
            <div class="toast-title">${title}</div>
            <div class="toast-message">${message}</div>
          </div>
          <button class="toast-close" aria-label="Close notification" onclick="dismissToast(${toastId})">×</button>
        `;

        // Add to container
        container.appendChild(toast);
        activeToasts.set(toastId, toast);

        // Trigger show animation
        requestAnimationFrame(() => {
          toast.classList.add("show");
        });

        // Auto-dismiss after duration
        if (duration > 0) {
          setTimeout(() => {
            dismissToast(toastId);
          }, duration);
        }

        return toastId;
      }

      function dismissToast(toastId) {
        const toast = activeToasts.get(toastId);
        if (!toast) return;

        toast.classList.remove("show");
        toast.classList.add("hide");

        setTimeout(() => {
          if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
          }
          activeToasts.delete(toastId);
        }, 300);
      }

      function dismissAllToasts() {
        for (const toastId of activeToasts.keys()) {
          dismissToast(toastId);
        }
      }

      // Keyboard support for toasts
      document.addEventListener("keydown", function (event) {
        // Escape key dismisses all toasts
        if (event.key === "Escape" && activeToasts.size > 0) {
          dismissAllToasts();
          event.preventDefault();
        }
      });

      // Initialize the application
      document.addEventListener("DOMContentLoaded", function () {
        initializeWebSocket();
        loadData();
        loadPubSubData();
        initializePerformanceCharts();

        // Auto-refresh data every 5 seconds as fallback
        setInterval(() => {
          if (!isConnected) {
            loadData();
            loadPubSubData();
            loadPerformanceData();
          }
        }, 5000);

        // Load performance data every 2 seconds
        setInterval(loadPerformanceData, 2000);
      });

      // WebSocket connection for real-time updates
      function initializeWebSocket() {
        try {
          const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
          const wsUrl = `${protocol}//${window.location.host}`;
          websocket = new WebSocket(wsUrl);

          websocket.onopen = function () {
            isConnected = true;
            updateConnectionStatus(true);
          };

          websocket.onmessage = function (event) {
            try {
              const data = JSON.parse(event.data);
              if (data.type === "data_update") {
                updateDataTable(data.data);
                // Update connection status indicator
                updateConnectionStatus(data.connected, data.message || data.error);
              } else if (data.type === "performance") {
                updatePerformanceMetrics(data.data);
              }
            } catch (error) {
              console.error("WebSocket message error:", error);
            }
          };

          websocket.onclose = function () {
            isConnected = false;
            updateConnectionStatus(false);
            // Try to reconnect after 3 seconds
            setTimeout(initializeWebSocket, 3000);
          };

          websocket.onerror = function (error) {
            console.error("WebSocket error:", error);
            isConnected = false;
            updateConnectionStatus(false);
          };
        } catch (error) {
          console.error("WebSocket initialization error:", error);
          isConnected = false;
          updateConnectionStatus(false);
        }
      }

      // Tab switching
      function switchTab(tabName) {
        // Update tab buttons
        document.querySelectorAll(".tab").forEach((tab) => {
          tab.classList.remove("active");
        });
        event.target.classList.add("active");

        // Update tab content
        document.querySelectorAll(".tab-content").forEach((content) => {
          content.classList.remove("active");
        });
        document.getElementById(tabName + "-tab").classList.add("active");

        currentTab = tabName;

        // Load data for the active tab
        if (tabName === "data") {
          loadData();
        } else if (tabName === "pubsub") {
          loadPubSubData();
        } else if (tabName === "performance") {
          loadPerformanceData();
          // Resize charts when tab becomes visible
          setTimeout(() => {
            Object.values(performanceCharts).forEach((chart) => {
              if (chart && chart.resize) {
                chart.resize();
              }
            });
          }, 100);
        }
      }

      // Handle action change in command interface
      function handleActionChange() {
        const action = document.getElementById("command-action").value;
        const keyGroup = document.getElementById("key-input-group");
        const valueGroup = document.getElementById("value-input-group");
        const ttlGroup = document.getElementById("ttl-input-group");

        // Reset visibility
        keyGroup.classList.remove("hidden");
        valueGroup.classList.add("hidden");
        ttlGroup.classList.add("hidden");

        // Show/hide inputs based on action
        switch (action) {
          case "PING":
            keyGroup.classList.add("hidden");
            break;
          case "GET":
          case "DELETE":
            // Only key input needed
            break;
          case "SET":
            valueGroup.classList.remove("hidden");
            break;
          case "SET_TTL":
            valueGroup.classList.remove("hidden");
            ttlGroup.classList.remove("hidden");
            break;
        }
      }

      // Load key-value data
      async function loadData() {
        const loadingEl = document.getElementById("data-loading");
        const errorEl = document.getElementById("data-error");
        const tableEl = document.getElementById("data-table");
        const noDataEl = document.getElementById("no-data");

        try {
          loadingEl.style.display = "block";
          errorEl.style.display = "none";
          tableEl.style.display = "none";
          noDataEl.style.display = "none";

          const response = await fetch("/api/data");
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const data = await response.json();
          updateDataTable(data);
        } catch (error) {
          console.error("Error loading data:", error);
          loadingEl.style.display = "none";
          errorEl.style.display = "block";
          errorEl.textContent = `Error loading data: ${error.message}`;
          tableEl.style.display = "none";
          noDataEl.style.display = "none";
        }
      }

      // Update connection status indicator
      function updateConnectionStatus(connected, message) {
        const statusElement = document.getElementById("connection-status");
        const statusText = document.getElementById("connection-status-text");

        if (connected) {
          statusElement.className = "connection-status connected";
          statusText.textContent = "Connected to Redis Core";
        } else {
          statusElement.className = "connection-status disconnected";
          statusText.textContent = message || "Redis Core Unavailable";
        }
      }

      // Update data table
      function updateDataTable(data) {
        const loadingEl = document.getElementById("data-loading");
        const errorEl = document.getElementById("data-error");
        const tableEl = document.getElementById("data-table");
        const noDataEl = document.getElementById("no-data");
        const tbody = document.getElementById("data-table-body");
        const keyCountEl = document.getElementById("key-count");
        const lastUpdateEl = document.getElementById("last-update");

        loadingEl.style.display = "none";
        errorEl.style.display = "none";

        if (data.length === 0) {
          tableEl.style.display = "none";
          noDataEl.style.display = "block";
        } else {
          tableEl.style.display = "table";
          noDataEl.style.display = "none";

          tbody.innerHTML = "";
          data.forEach((item) => {
            const row = document.createElement("tr");

            const ttlDisplay =
              item.ttl !== null
                ? `<span class="ttl-badge ttl-active">${escapeHtml(String(item.ttl))}s</span>`
                : `<span class="ttl-badge ttl-none">∞</span>`;

            row.innerHTML = `
                        <td><code>${escapeHtml(item.key)}</code></td>
                        <td><code>${escapeHtml(item.value)}</code></td>
                        <td>${escapeHtml(String(item.type))}</td>
                        <td>${ttlDisplay}</td>
                    `;

            tbody.appendChild(row);
          });
        }

        // Update status
        keyCountEl.textContent = `${data.length} key${data.length !== 1 ? "s" : ""}`;
        lastUpdateEl.textContent = `Updated ${new Date().toLocaleTimeString()}`;
      }

      // Execute Redis command
      async function executeCommand() {
        const action = document.getElementById("command-action").value;
        const key = document.getElementById("command-key").value.trim();
        const value = document.getElementById("command-value").value.trim();
        const ttl = document.getElementById("command-ttl").value.trim();

        // Build command based on action
        let command = "";
        switch (action) {
          case "PING":
            command = "PING";
            break;
          case "GET":
            if (!key) {
              showCommandError("Please enter a key name");
              return;
            }
            command = `GET ${key}`;
            break;
          case "SET":
            if (!key || !value) {
              showCommandError("Please enter both key and value");
              return;
            }
            command = `SET ${key} "${value}"`;
            break;
          case "DELETE":
            if (!key) {
              showCommandError("Please enter a key name");
              return;
            }
            command = `DEL ${key}`;
            break;
          case "SET_TTL":
            if (!key || !value || !ttl) {
              showCommandError("Please enter key, value, and TTL");
              return;
            }
            if (isNaN(ttl) || parseInt(ttl) <= 0) {
              showCommandError("TTL must be a positive number");
              return;
            }
            command = `SET ${key} "${value}"`;
            break;
        }

        try {
          const response = await fetch("/api/command", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ command }),
          });

          const result = await response.json();

          if (result.success) {
            // If SET_TTL, execute EXPIRE command after SET
            if (action === "SET_TTL") {
              const expireResponse = await fetch("/api/command", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({ command: `EXPIRE ${key} ${ttl}` }),
              });

              const expireResult = await expireResponse.json();
              if (expireResult.success) {
                showCommandSuccess(`Key set with TTL of ${ttl} seconds`);
                appendCommandResult(
                  `> ${command}\n${result.response}\n> EXPIRE ${key} ${ttl}\n${expireResult.response}\n`
                );
              } else {
                showCommandError(`Set succeeded but TTL failed: ${expireResult.error}`);
                appendCommandResult(
                  `> ${command}\n${result.response}\n> EXPIRE ${key} ${ttl}\nERROR: ${expireResult.error}\n`
                );
              }
            } else {
              showCommandSuccess(`Command executed successfully`);
              appendCommandResult(`> ${command}\n${result.response}\n`);
            }

            // Clear inputs and refresh data if it was a data-modifying command
            if (action !== "PING" && action !== "GET") {
              document.getElementById("command-key").value = "";
              document.getElementById("command-value").value = "";
              document.getElementById("command-ttl").value = "";
              loadData();
            }
          } else {
            showCommandError(result.error || "Command failed");
            appendCommandResult(`> ${command}\nERROR: ${result.error}\n`);
          }
        } catch (error) {
          showCommandError(`Network error: ${error.message}`);
          appendCommandResult(`> ${command}\nNETWORK ERROR: ${error.message}\n`);
        }
      }

      // Quick command execution (for pub-sub testing)
      function quickCommand(command) {
        // This is now only used for pub-sub commands in the pub-sub tab
        // We'll implement a simple command execution for these cases
        executeSimpleCommand(command);
      }

      // Execute simple command (for pub-sub testing)
      async function executeSimpleCommand(command) {
        try {
          const response = await fetch("/api/command", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ command }),
          });

          const result = await response.json();

          if (result.success) {
            console.log(`Command executed: ${command} -> ${result.response}`);
          } else {
            console.error(`Command failed: ${command} -> ${result.error}`);
          }
        } catch (error) {
          console.error(`Network error: ${error.message}`);
        }
      }

      // Show command success message
      function showCommandSuccess(message) {
        showToast(message, "success", "Command Successful");
      }

      // Show command error message
      function showCommandError(message) {
        showToast(message, "error", "Command Error");
      }

      // Append to command result
      function appendCommandResult(text) {
        const resultEl = document.getElementById("command-result");
        resultEl.textContent += text + "\n";
        resultEl.scrollTop = resultEl.scrollHeight;
      }

      // Clear command result
      function clearCommandResult() {
        const resultEl = document.getElementById("command-result");
        resultEl.textContent =
          'Ready to execute commands...\n\nExamples:\nSET greeting "Hello World"\nGET greeting\nEXPIRE greeting 30\nDEL greeting\nPING\n';
      }

      // Clear all data
      async function clearAllData() {
        if (!confirm("Are you sure you want to delete all keys? This action cannot be undone.")) {
          return;
        }

        try {
          // Get all keys first
          const response = await fetch("/api/data");
          const data = await response.json();

          if (data.length === 0) {
            alert("No keys to delete");
            return;
          }

          // Delete all keys
          const keys = data.map((item) => item.key).join(" ");
          const deleteResponse = await fetch("/api/command", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ command: `DEL ${keys}` }),
          });

          const result = await deleteResponse.json();

          if (result.success) {
            alert(`Successfully deleted ${result.response} keys`);
            loadData();
          } else {
            alert(`Error deleting keys: ${result.error}`);
          }
        } catch (error) {
          alert(`Error: ${error.message}`);
        }
      }

      // Load Pub/Sub data
      async function loadPubSubData() {
        try {
          const response = await fetch("/api/pubsub");
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const channels = await response.json();
          updateChannelList(channels);
        } catch (error) {
          console.error("Error loading pub/sub data:", error);
        }
      }

      // Update channel list
      function updateChannelList(channels) {
        const channelListEl = document.getElementById("channel-list");

        if (channels.length === 0) {
          channelListEl.innerHTML =
            '<div style="text-align: center; color: #6c757d; padding: 2rem;">No active channels</div>';
        } else {
          channelListEl.innerHTML = "";
          channels.forEach((channel) => {
            const channelEl = document.createElement("div");
            channelEl.className = "channel-item";
            channelEl.innerHTML = `
                        <span><strong>${escapeHtml(channel.channel)}</strong></span>
                        <span class="subscriber-count">${channel.subscribers}</span>
                    `;
            channelListEl.appendChild(channelEl);
          });
        }
      }

      // Add message to log
      function addMessageToLog(channel, message) {
        const messageLogEl = document.getElementById("message-log");
        const timestamp = new Date().toLocaleTimeString();

        if (messageLog.length === 0) {
          messageLogEl.innerHTML = "";
        }

        const messageEl = document.createElement("div");
        messageEl.className = "message-item";
        messageEl.innerHTML = `
                <div class="message-timestamp">${timestamp}</div>
                <div><strong>${escapeHtml(channel)}:</strong> ${escapeHtml(message)}</div>
            `;

        messageLogEl.appendChild(messageEl);
        messageLog.push({ channel, message, timestamp });

        // Keep only last 50 messages
        if (messageLog.length > 50) {
          messageLog.shift();
          messageLogEl.removeChild(messageLogEl.firstChild);
        }

        messageLogEl.scrollTop = messageLogEl.scrollHeight;
      }

      // Utility function to escape HTML
      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // Performance monitoring functions
      function initializePerformanceCharts() {
        const chartConfig = {
          type: "line",
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              intersect: false,
              mode: "index",
            },
            scales: {
              x: {
                display: false,
                grid: {
                  display: false,
                },
              },
              y: {
                beginAtZero: true,
                grid: {
                  color: "rgba(0,0,0,0.1)",
                },
                ticks: {
                  font: {
                    size: 11,
                  },
                  maxTicksLimit: 6,
                },
              },
            },
            plugins: {
              legend: {
                display: false,
              },
              tooltip: {
                enabled: true,
                mode: "nearest",
                intersect: false,
              },
            },
            elements: {
              point: {
                radius: 0,
                hoverRadius: 4,
              },
              line: {
                borderWidth: 2,
                tension: 0.1,
              },
            },
            animation: {
              duration: 0, // Disable animations for better performance
            },
            layout: {
              padding: {
                top: 10,
                bottom: 10,
                left: 10,
                right: 10,
              },
            },
          },
        };

        // Initialize cache charts
        performanceCharts.cacheRps = new Chart(document.getElementById("cache-rps-chart"), {
          ...chartConfig,
          data: {
            labels: Array(maxDataPoints).fill(""),
            datasets: [
              {
                data: Array(maxDataPoints).fill(0),
                borderColor: "#007bff",
                backgroundColor: "rgba(0, 123, 255, 0.1)",
                fill: true,
              },
            ],
          },
        });

        performanceCharts.cacheLatency = new Chart(document.getElementById("cache-latency-chart"), {
          ...chartConfig,
          data: {
            labels: Array(maxDataPoints).fill(""),
            datasets: [
              {
                data: Array(maxDataPoints).fill(0),
                borderColor: "#28a745",
                backgroundColor: "rgba(40, 167, 69, 0.1)",
                fill: true,
              },
            ],
          },
        });

        performanceCharts.cacheHitRate = new Chart(document.getElementById("cache-hit-rate-chart"), {
          ...chartConfig,
          data: {
            labels: Array(maxDataPoints).fill(""),
            datasets: [
              {
                data: Array(maxDataPoints).fill(0),
                borderColor: "#ffc107",
                backgroundColor: "rgba(255, 193, 7, 0.1)",
                fill: true,
              },
            ],
          },
          options: {
            ...chartConfig.options,
            scales: {
              ...chartConfig.options.scales,
              y: {
                beginAtZero: true,
                max: 100,
              },
            },
          },
        });

        // Initialize pub/sub charts
        performanceCharts.pubsubPublished = new Chart(document.getElementById("pubsub-published-chart"), {
          ...chartConfig,
          data: {
            labels: Array(maxDataPoints).fill(""),
            datasets: [
              {
                data: Array(maxDataPoints).fill(0),
                borderColor: "#dc3545",
                backgroundColor: "rgba(220, 53, 69, 0.1)",
                fill: true,
              },
            ],
          },
        });

        performanceCharts.pubsubConsumed = new Chart(document.getElementById("pubsub-consumed-chart"), {
          ...chartConfig,
          data: {
            labels: Array(maxDataPoints).fill(""),
            datasets: [
              {
                data: Array(maxDataPoints).fill(0),
                borderColor: "#6f42c1",
                backgroundColor: "rgba(111, 66, 193, 0.1)",
                fill: true,
              },
            ],
          },
        });

        performanceCharts.pubsubLatency = new Chart(document.getElementById("pubsub-latency-chart"), {
          ...chartConfig,
          data: {
            labels: Array(maxDataPoints).fill(""),
            datasets: [
              {
                data: Array(maxDataPoints).fill(0),
                borderColor: "#fd7e14",
                backgroundColor: "rgba(253, 126, 20, 0.1)",
                fill: true,
              },
            ],
          },
        });
      }

      // Load performance data from API
      async function loadPerformanceData() {
        try {
          const response = await fetch("/api/performance");
          if (response.ok) {
            const data = await response.json();
            updatePerformanceMetrics(data);
          }
        } catch (error) {
          console.error("Failed to load performance data:", error);
        }
      }

      // Update performance metrics and charts
      function updatePerformanceMetrics(data) {
        // Update cache metrics
        document.getElementById("cache-rps").textContent = data.cache.requestsPerSecond.toFixed(2);
        document.getElementById("cache-latency").textContent = data.cache.latencyP99.toFixed(2);
        document.getElementById("cache-hit-rate").textContent = data.cache.hitRate.toFixed(1);

        // Update pub/sub metrics
        document.getElementById("pubsub-published").textContent = data.pubsub.messagesPublishedPerSecond.toFixed(2);
        document.getElementById("pubsub-consumed").textContent = data.pubsub.messagesConsumedPerSecond.toFixed(2);
        document.getElementById("pubsub-latency").textContent = data.pubsub.latencyP99.toFixed(2);

        // Update system metrics
        document.getElementById("system-connections").textContent = data.system.connections;
        document.getElementById("system-memory").textContent = data.system.memoryUsage.toFixed(1);
        document.getElementById("system-uptime").textContent = Math.floor(data.system.uptime / 1000);

        // Update charts
        updateChart(performanceCharts.cacheRps, data.cache.requestsPerSecond);
        updateChart(performanceCharts.cacheLatency, data.cache.latencyP99);
        updateChart(performanceCharts.cacheHitRate, data.cache.hitRate);
        updateChart(performanceCharts.pubsubPublished, data.pubsub.messagesPublishedPerSecond);
        updateChart(performanceCharts.pubsubConsumed, data.pubsub.messagesConsumedPerSecond);
        updateChart(performanceCharts.pubsubLatency, data.pubsub.latencyP99);
      }

      // Update individual chart with new data point
      function updateChart(chart, newValue) {
        const data = chart.data.datasets[0].data;
        data.shift(); // Remove first element
        data.push(newValue); // Add new element
        chart.update("none"); // Update without animation for better performance
      }

      // Handle pub/sub action change
      function handlePubSubActionChange() {
        const action = document.getElementById("pubsub-action").value;
        const messageRow = document.getElementById("pubsub-message-row");

        if (action === "PUBLISH") {
          messageRow.style.display = "flex";
        } else {
          messageRow.style.display = "none";
          document.getElementById("pubsub-message").value = "";
        }
      }

      // Execute pub/sub command
      async function executePubSubCommand() {
        const action = document.getElementById("pubsub-action").value;
        const channel = document.getElementById("pubsub-channel").value.trim();
        const message = document.getElementById("pubsub-message").value.trim();

        // Validate inputs
        if (!channel) {
          showPubSubResult("Error: Channel name is required", "error");
          return;
        }

        if (action === "PUBLISH" && !message) {
          showPubSubResult("Error: Message content is required for PUBLISH command", "error");
          return;
        }

        // Format command
        let command;
        switch (action) {
          case "SUBSCRIBE":
            command = `SUBSCRIBE ${channel}`;
            break;
          case "PUBLISH":
            command = `PUBLISH ${channel} "${message}"`;
            break;
          case "UNSUBSCRIBE":
            command = `UNSUBSCRIBE ${channel}`;
            break;
          default:
            showPubSubResult("Error: Invalid action selected", "error");
            return;
        }

        // Show loading state
        showPubSubResult(`Executing: ${command}`, "");

        try {
          const response = await fetch("/api/command", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ command }),
          });

          const result = await response.json();

          if (result.success) {
            showPubSubResult(`✓ ${command}\nResponse: ${result.response}`, "success");

            // Add to message log for pub/sub commands
            if (action === "SUBSCRIBE" || action === "UNSUBSCRIBE") {
              addToMessageLog(`[${new Date().toLocaleTimeString()}] ${command} -> ${result.response}`);
            } else if (action === "PUBLISH") {
              addToMessageLog(
                `[${new Date().toLocaleTimeString()}] Published to ${channel}: "${message}" -> ${
                  result.response
                } subscriber(s)`
              );
            }

            // Refresh pub/sub data to update active channels
            loadPubSubData();
          } else {
            showPubSubResult(`✗ ${command}\nError: ${result.error}`, "error");
          }
        } catch (error) {
          showPubSubResult(`✗ ${command}\nNetwork Error: ${error.message}`, "error");
        }
      }

      // Show pub/sub command result
      function showPubSubResult(message, type) {
        // Determine toast title based on type
        let title = "Pub/Sub Command";
        if (type === "success") {
          title = "Command Successful";
        } else if (type === "error") {
          title = "Command Failed";
        }

        // Show toast notification
        showToast(message, type, title);
      }

      // Add message to the message log
      function addToMessageLog(message) {
        messageLog.push(message);

        // Keep only last 50 messages
        if (messageLog.length > 50) {
          messageLog.shift();
        }

        // Update message log display if it exists
        const messageLogElement = document.getElementById("message-log");
        if (messageLogElement) {
          messageLogElement.textContent = messageLog.join("\n");
          messageLogElement.scrollTop = messageLogElement.scrollHeight;
        }
      }

      // Handle window beforeunload
      window.addEventListener("beforeunload", function () {
        if (websocket) {
          websocket.close();
        }
      });
    </script>
  </body>
</html>
